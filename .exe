<!-- /index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ultimate RPG - Executive Edition</title>
  <style>
    :root {
      --bg: #05080f;
      --panel: #101724;
      --panel-alt: #0b111c;
      --border: #1b2535;
      --text: #f1f5fb;
      --muted: #9aafc6;
      --accent: #67b7ff;
      --accent-2: #6affc5;
      --danger: #ff6b8b;
      --success: #82ff9b;
      --warning: #ffd66b;
      --radius: 16px;
      --shadow: 0 20px 40px rgba(0, 0, 0, 0.35);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      background: radial-gradient(1200px 600px at 70% -10%, #17243c 0%, #05080f 60%) fixed;
      color: var(--text);
      font: 15px/1.6 "Inter", "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      min-height: 100vh;
    }

    body::-webkit-scrollbar {
      width: 10px;
    }

    body::-webkit-scrollbar-thumb {
      background: #111b2b;
      border-radius: 10px;
    }

    .app {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      position: sticky;
      top: 0;
      z-index: 20;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 14px 18px;
      background: rgba(5, 11, 18, 0.92);
      backdrop-filter: blur(14px);
      border-bottom: 1px solid var(--border);
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.45);
    }

    header .brand {
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 700;
    }

    .brand .logo {
      width: 28px;
      height: 28px;
      border-radius: 10px;
      background: linear-gradient(135deg, var(--accent), var(--accent-2));
      box-shadow: 0 10px 25px rgba(102, 190, 255, 0.45);
    }

    nav {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }

    button {
      font: inherit;
      color: inherit;
      cursor: pointer;
      background: none;
      border: none;
    }

    button:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    .btn {
      border-radius: 12px;
      border: 1px solid var(--border);
      padding: 8px 14px;
      background: linear-gradient(180deg, #142030, #0e1826);
      color: inherit;
      transition: transform 0.08s ease, box-shadow 0.12s ease;
      box-shadow: 0 2px 0 rgba(0, 0, 0, 0.6);
    }

    .btn:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
    }

    .btn:active:not(:disabled) {
      transform: translateY(0);
    }

    .btn:disabled {
      opacity: 0.55;
      cursor: not-allowed;
    }

    .btn.primary {
      border-color: #264978;
      background: linear-gradient(180deg, #1f3354, #142033);
    }

    .btn.warn {
      border-color: var(--warning);
      color: var(--warning);
    }

    .btn.danger {
      border-color: var(--danger);
      color: var(--danger);
    }

    main {
      flex: 1;
      padding: 18px;
    }

    h1, h2, h3, h4 {
      margin: 0;
      font-weight: 700;
    }

    h1 {
      font-size: 2.4rem;
    }

    h2 {
      font-size: 1.6rem;
    }

    h3 {
      font-size: 1.3rem;
    }

    p {
      margin: 0;
    }

    .muted {
      color: var(--muted);
    }

    .panel {
      background: linear-gradient(180deg, var(--panel), var(--panel-alt));
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 18px;
      box-shadow: var(--shadow);
      display: flex;
      flex-direction: column;
      gap: 14px;
    }

    .panel.outline {
      background: rgba(15, 24, 36, 0.6);
      border-style: dashed;
    }

    .panel + .panel {
      margin-top: 18px;
    }

    .grid {
      display: grid;
      gap: 14px;
    }

    .cols-2 {
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }

    .cols-3 {
      grid-template-columns: repeat(3, minmax(0, 1fr));
    }

    @media (max-width: 980px) {
      .cols-2,
      .cols-3 {
        grid-template-columns: minmax(0, 1fr);
      }

      h1 {
        font-size: 1.8rem;
      }
    }

    .stat-list {
      display: grid;
      gap: 6px;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid rgba(36, 50, 70, 0.8);
      background: rgba(11, 18, 30, 0.6);
    }

    .progress {
      width: 100%;
      height: 10px;
      border-radius: 999px;
      border: 1px solid rgba(45, 66, 94, 0.9);
      background: rgba(8, 12, 18, 0.9);
      overflow: hidden;
    }

    .progress span {
      display: block;
      height: 100%;
      background: linear-gradient(90deg, var(--accent), var(--accent-2));
    }

    .tag {
      border-radius: 999px;
      border: 1px solid rgba(45, 66, 94, 0.9);
      padding: 3px 9px;
      font-size: 12px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: rgba(15, 22, 34, 0.75);
    }

    .badge-strip {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .map-grid {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    }

    .map-node {
      border-radius: 14px;
      border: 1px solid rgba(45, 65, 95, 0.8);
      padding: 14px;
      background: rgba(15, 24, 34, 0.85);
      box-shadow: 0 12px 28px rgba(0, 0, 0, 0.25);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .map-node[data-cleared="true"] {
      opacity: 0.55;
    }

    .map-node h4 {
      font-size: 1.05rem;
    }

    .battle-wrap {
      display: grid;
      gap: 18px;
    }

    .battle-stats {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    }

    .battle-log {
      max-height: 280px;
      overflow-y: auto;
      border-radius: 12px;
      border: 1px solid rgba(40, 58, 83, 0.8);
      padding: 10px;
      background: rgba(8, 12, 18, 0.75);
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 0.95rem;
    }

    .log-line strong {
      color: var(--accent);
    }

    .inventory {
      display: grid;
      gap: 10px;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
    }

    .inventory .item {
      border-radius: 12px;
      border: 1px solid rgba(46, 68, 100, 0.9);
      padding: 10px;
      background: rgba(12, 20, 32, 0.85);
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .toast-wrap {
      position: fixed;
      right: 20px;
      bottom: 20px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 200;
    }

    .toast {
      background: rgba(9, 14, 22, 0.92);
      border-radius: 12px;
      padding: 10px 14px;
      border: 1px solid rgba(50, 78, 112, 0.8);
      min-width: 220px;
      box-shadow: 0 12px 22px rgba(0, 0, 0, 0.4);
    }

    .toast.fade-out {
      opacity: 0;
      transform: translateY(8px);
      transition: opacity 0.28s ease, transform 0.28s ease;
    }

    .toast.success {
      border-color: rgba(102, 255, 173, 0.9);
      color: var(--success);
    }

    .toast.error {
      border-color: rgba(255, 107, 139, 0.9);
      color: var(--danger);
    }

    .toast.warn {
      border-color: rgba(255, 214, 107, 0.9);
      color: var(--warning);
    }

    .overlay-hint {
      position: fixed;
      left: 50%;
      bottom: 24px;
      transform: translateX(-50%);
      background: rgba(12, 19, 28, 0.92);
      border: 1px solid rgba(50, 78, 112, 0.9);
      border-radius: 16px;
      padding: 10px 18px;
      box-shadow: 0 18px 28px rgba(0, 0, 0, 0.4);
      z-index: 160;
      display: none;
      color: var(--muted);
    }

    .overlay-hint.show {
      display: block;
    }

    [data-gamepad-focus].gamepad-focus {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
      box-shadow: 0 0 0 2px rgba(103, 183, 255, 0.35);
      position: relative;
      z-index: 10;
    }

    [data-gamepad-focus].gamepad-focus::after {
      content: '';
      position: absolute;
      inset: -6px;
      border-radius: inherit;
      border: 1px solid rgba(103, 183, 255, 0.45);
      pointer-events: none;
    }

    .empty-state {
      text-align: center;
      padding: 26px 18px;
      border-radius: var(--radius);
      border: 1px dashed rgba(45, 66, 94, 0.7);
      background: rgba(12, 20, 32, 0.5);
    }

    .title-card {
      max-width: 780px;
      margin: 0 auto;
      text-align: center;
      display: flex;
      flex-direction: column;
      gap: 22px;
      padding: 32px;
    }

    .title-card .cta-group {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .cta-group {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: flex-start;
    }

    .quest-list {
      display: grid;
      gap: 10px;
    }

    .quest {
      border-radius: 12px;
      border: 1px solid rgba(45, 66, 94, 0.8);
      background: rgba(12, 20, 30, 0.8);
      padding: 10px 12px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .shop-grid {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }

    .shop-card {
      border-radius: 14px;
      border: 1px solid rgba(45, 66, 94, 0.85);
      background: rgba(10, 17, 28, 0.8);
      padding: 14px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .skills-grid {
      display: grid;
      gap: 14px;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }

    .skill-card {
      border-radius: 14px;
      border: 1px solid rgba(57, 86, 125, 0.8);
      background: rgba(11, 19, 30, 0.85);
      padding: 14px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .settings-list {
      display: grid;
      gap: 12px;
    }

    label.switch {
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-radius: 12px;
      border: 1px solid rgba(45, 66, 94, 0.8);
      padding: 10px 12px;
      background: rgba(11, 18, 28, 0.8);
      gap: 10px;
    }

    .codex {
      display: grid;
      gap: 14px;
    }

    .codex section {
      border-radius: 14px;
      border: 1px solid rgba(45, 66, 94, 0.8);
      padding: 16px;
      background: rgba(8, 14, 22, 0.75);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .codex ul {
      margin: 0;
      padding-left: 20px;
      color: var(--muted);
    }

    .codex li {
      margin-bottom: 6px;
    }

    .divider {
      height: 1px;
      background: rgba(35, 48, 68, 0.8);
      border-radius: 1px;
    }
  </style>
</head>
<body>
  <div class="app" id="app">
    <header>
      <div class="brand" aria-label="Ultimate RPG">
        <div class="logo" aria-hidden="true"></div>
        <div>
          <div>Ultimate RPG</div>
          <small class="muted">Executive Edition v3.0.0</small>
        </div>
      </div>
      <nav aria-label="Primary">
        <button class="btn ghost" data-route="title" title="Title (T)">Title</button>
        <button class="btn ghost" data-route="hub" title="Hub (H)">Hub</button>
        <button class="btn ghost" data-route="map" title="Map (M)">Map</button>
        <button class="btn ghost" data-route="battle" title="Battle (B)">Battle</button>
        <button class="btn ghost" data-route="shop" title="Shop (S)">Shop</button>
        <button class="btn ghost" data-route="skills" title="Skills (K)">Skills</button>
        <button class="btn ghost" data-route="settings" title="Settings (G)">Settings</button>
        <button class="btn ghost" data-route="codex" title="Codex (C)">Codex</button>
        <button class="btn ghost" id="btn-save" title="Save (Ctrl+S)">Save</button>
        <button class="btn ghost danger" id="btn-reset" title="Reset">Reset</button>
      </nav>
    </header>
    <main id="view" role="main"></main>
  </div>
  <div id="toasts" class="toast-wrap" aria-live="polite" aria-atomic="false"></div>
  <div class="overlay-hint" id="gamepad-hint" role="status" aria-live="polite">Gamepad detected. Use the stick or D-pad to navigate, A to activate, and B to backtrack.</div>

  <script>
    (() => {
      const VERSION = '3.0.0';
      const STORAGE_KEY = 'ultimate-rpg-executive-save';

      const ABILITY_LIBRARY = {
        strike: {
          id: 'strike',
          name: 'Vanguard Strike',
          cost: 0,
          description: 'Reliable melee strike scaling with Strength.',
          execute: ({ player, enemy }) => {
            const roll = randomRange(0.8, 1.2);
            const base = player.stats.strength * 2 + player.equipment.weapon.power;
            const damage = Math.max(2, Math.round(base * roll - enemy.defense));
            enemy.hp = Math.max(0, enemy.hp - damage);
            return `${player.name} strikes for ${damage} damage!`;
          }
        },
        rally: {
          id: 'rally',
          name: 'Battle Rally',
          cost: 3,
          description: 'Restore armour focus and grant a shield.',
          execute: ({ player }) => {
            const shield = Math.round(player.stats.endurance * 1.5 + 6);
            player.tempShield = (player.tempShield || 0) + shield;
            return `${player.name} rallies, gaining ${shield} shield!`;
          }
        },
        smite: {
          id: 'smite',
          name: 'Skyfall Smite',
          cost: 5,
          description: 'Heavy single target ability scaling with Strength and Spirit.',
          execute: ({ player, enemy }) => {
            const roll = randomRange(1.1, 1.45);
            const base = player.stats.strength * 1.5 + player.stats.spirit * 1.4 + player.equipment.weapon.power;
            const damage = Math.max(6, Math.round(base * roll - enemy.defense * 0.5));
            enemy.hp = Math.max(0, enemy.hp - damage);
            return `${player.name} smites for ${damage} damage!`;
          }
        }
      };

      const ITEM_LIBRARY = {
        potion: {
          id: 'potion',
          name: 'Vanguard Draught',
          description: 'Restores 18 HP.',
          price: 18,
          use: (player) => {
            const amount = 18;
            const heal = Math.min(amount, player.hpMax - player.hp);
            player.hp = Math.min(player.hpMax, player.hp + amount);
            return heal;
          }
        },
        ether: {
          id: 'ether',
          name: 'Mind Tonic',
          description: 'Restores 8 MP.',
          price: 20,
          use: (player) => {
            const amount = 8;
            const restore = Math.min(amount, player.mpMax - player.mp);
            player.mp = Math.min(player.mpMax, player.mp + amount);
            return restore;
          }
        },
        bomb: {
          id: 'bomb',
          name: 'Stormfire Bomb',
          description: 'Deals 20 true damage to an enemy.',
          price: 40,
          use: (player, enemy) => {
            enemy.hp = Math.max(0, enemy.hp - 20);
            return 20;
          }
        }
      };

      const ENEMY_DECK = [
        { templateId: 'raider', name: 'Duskhaven Raider', hpBase: 28, attack: 6, defense: 2, description: 'Swift attacker that punishes slow openings.' },
        { templateId: 'sage', name: 'Frost Sage', hpBase: 32, attack: 5, defense: 3, description: 'Prefers chilling spells over raw force.' },
        { templateId: 'brute', name: 'Runic Brute', hpBase: 36, attack: 7, defense: 4, description: 'Armoured juggernaut with a heavy swing.' },
        { templateId: 'assailant', name: 'Gloom Assailant', hpBase: 24, attack: 9, defense: 1, description: 'Hits first, hits hard, but can be burst down.' }
      ];

      const QUEST_LIBRARY = [
        { id: 'clear-encounters', name: 'Anchor the Front', description: 'Win three battles to secure the region.', goal: 3, reward: { xp: 40, gold: 25 } },
        { id: 'gather-gold', name: 'Logistics Ledger', description: 'Accrue 150 gold to fund the expedition.', goal: 150, reward: { xp: 35, gold: 40 }, progressType: 'currency' }
      ];

      const ROUTE_RENDERERS = {
        title: renderTitle,
        hub: renderHub,
        map: renderMap,
        battle: renderBattle,
        shop: renderShop,
        skills: renderSkills,
        settings: renderSettings,
        codex: renderCodex
      };

      const navButtons = Array.from(document.querySelectorAll('nav [data-route]'));
      const view = document.getElementById('view');
      const toastWrap = document.getElementById('toasts');
      const saveBtn = document.getElementById('btn-save');
      const resetBtn = document.getElementById('btn-reset');
      const gamepadHint = document.getElementById('gamepad-hint');

      let state = null;
      let currentRoute = 'title';

      const GamepadState = {
        connected: false,
        padIndex: null,
        focusables: [],
        index: -1,
        nextMove: 0,
        buttonLatch: new Map(),
        pollHandle: null
      };

      function decorateGamepadTargets(root = document) {
        if (!root) return;
        const elements = root.querySelectorAll('button, input, select');
        elements.forEach((el) => {
          if (el.tagName === 'BUTTON') {
            if (!el.dataset.gamepadFocus) {
              if (el.closest('nav')) {
                el.dataset.gamepadFocus = 'route';
              } else if (el.dataset.ability) {
                el.dataset.gamepadFocus = 'ability';
              } else if (el.dataset.node) {
                el.dataset.gamepadFocus = 'map';
              } else if (el.dataset.itemEquip || el.dataset.itemUse) {
                el.dataset.gamepadFocus = 'inventory';
              } else if (el.dataset.buy || el.dataset.sell) {
                el.dataset.gamepadFocus = 'shop';
              } else if (el.dataset.skill) {
                el.dataset.gamepadFocus = 'skill';
              } else if (el.dataset.claimQuest) {
                el.dataset.gamepadFocus = 'quest';
              } else if (el.id && el.id.startsWith('btn-')) {
                el.dataset.gamepadFocus = 'action';
              } else {
                el.dataset.gamepadFocus = 'action';
              }
            }
            if (!el.hasAttribute('aria-describedby')) {
              el.setAttribute('aria-describedby', 'gamepad-hint');
            }
          } else {
            if (!el.dataset.gamepadFocus) {
              el.dataset.gamepadFocus = 'setting';
            }
            if (!el.hasAttribute('aria-describedby')) {
              el.setAttribute('aria-describedby', 'gamepad-hint');
            }
          }
        });
        const retreat = root.querySelector('#btn-retreat');
        if (retreat) {
          retreat.setAttribute('data-gamepad-back', 'true');
        }
      }

      function toggleGamepadHint(show) {
        if (!gamepadHint) return;
        gamepadHint.classList.toggle('show', !!show);
      }

      function isFocusableForGamepad(el) {
        if (!el || el.disabled || el.getAttribute('aria-disabled') === 'true') return false;
        const style = window.getComputedStyle(el);
        if (style.visibility === 'hidden' || style.display === 'none') return false;
        const rect = el.getBoundingClientRect();
        return rect.width > 0 && rect.height > 0;
      }

      function clearGamepadFocus() {
        GamepadState.focusables.forEach((el) => {
          el.classList.remove('gamepad-focus');
          el.removeAttribute('data-gamepad-active');
        });
        GamepadState.index = -1;
      }

      function ensureGamepadFocus(index) {
        const list = GamepadState.focusables;
        if (!list.length) {
          clearGamepadFocus();
          return;
        }
        const clamped = ((index % list.length) + list.length) % list.length;
        if (GamepadState.index === clamped && list[clamped]?.classList.contains('gamepad-focus')) {
          return;
        }
        if (GamepadState.index >= 0 && list[GamepadState.index]) {
          list[GamepadState.index].classList.remove('gamepad-focus');
          list[GamepadState.index].removeAttribute('data-gamepad-active');
        }
        GamepadState.index = clamped;
        const target = list[clamped];
        if (!target) return;
        target.classList.add('gamepad-focus');
        target.setAttribute('data-gamepad-active', 'true');
        if (typeof target.scrollIntoView === 'function') {
          target.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
        }
      }

      function refreshGamepadFocusables() {
        const focusables = Array.from(document.querySelectorAll('[data-gamepad-focus]')).filter(isFocusableForGamepad);
        GamepadState.focusables = focusables;
        if (!GamepadState.connected) {
          clearGamepadFocus();
          return;
        }
        if (!focusables.length) {
          clearGamepadFocus();
          return;
        }
        const current = focusables[GamepadState.index];
        if (current) {
          ensureGamepadFocus(GamepadState.index);
        } else {
          ensureGamepadFocus(0);
        }
      }

      function moveGamepadFocus(delta) {
        if (!GamepadState.connected || !GamepadState.focusables.length) return;
        ensureGamepadFocus(GamepadState.index + delta);
      }

      function activateFocusedElement() {
        if (!GamepadState.connected) return;
        const el = GamepadState.focusables[GamepadState.index];
        if (!el) return;
        if (typeof el.click === 'function') {
          el.click();
        } else {
          el.dispatchEvent(new Event('click', { bubbles: true }));
        }
      }

      function triggerGamepadBack() {
        if (!GamepadState.connected) return;
        const backEl = GamepadState.focusables.find((el) => el.dataset.gamepadBack && isFocusableForGamepad(el));
        if (backEl) {
          backEl.click();
          return;
        }
        const navBack = Array.from(document.querySelectorAll('nav [data-route]')).find((btn) => !btn.disabled);
        if (navBack) {
          navBack.click();
        }
      }

      function handleGamepadButtons(pad) {
        const mapping = [
          { index: 12, delta: -1 },
          { index: 13, delta: 1 },
          { index: 14, delta: -1 },
          { index: 15, delta: 1 }
        ];
        const now = performance.now();
        mapping.forEach(({ index, delta }) => {
          const pressed = !!pad.buttons[index]?.pressed;
          const prev = GamepadState.buttonLatch.get(index) || false;
          if (pressed && !prev) {
            moveGamepadFocus(delta);
            GamepadState.nextMove = now + 220;
          }
          GamepadState.buttonLatch.set(index, pressed);
        });

        const buttonActions = [
          { index: 0, action: activateFocusedElement },
          { index: 1, action: triggerGamepadBack },
          { index: 4, action: triggerGamepadBack }
        ];
        buttonActions.forEach(({ index, action }) => {
          const pressed = !!pad.buttons[index]?.pressed;
          const prev = GamepadState.buttonLatch.get(index) || false;
          if (pressed && !prev) {
            action();
          }
          GamepadState.buttonLatch.set(index, pressed);
        });
      }

      function processGamepad(pad) {
        if (!pad) return;
        handleGamepadButtons(pad);
        const horizontal = pad.axes[0] || 0;
        const vertical = pad.axes[1] || 0;
        const dominant = Math.abs(horizontal) > Math.abs(vertical) ? horizontal : vertical;
        const direction = Math.abs(dominant) > 0.5 ? (dominant > 0 ? 1 : -1) : 0;
        const now = performance.now();
        if (direction !== 0) {
          if (GamepadState.nextMove <= now) {
            moveGamepadFocus(direction);
            GamepadState.nextMove = now + 260;
          }
        } else {
          GamepadState.nextMove = 0;
        }
      }

      function pollGamepad() {
        if (!GamepadState.connected) return;
        const pads = navigator.getGamepads ? navigator.getGamepads() : [];
        const pad = pads[GamepadState.padIndex];
        if (!pad) {
          handleGamepadDisconnection({ index: GamepadState.padIndex });
          return;
        }
        processGamepad(pad);
        GamepadState.pollHandle = window.requestAnimationFrame(pollGamepad);
      }

      function handleGamepadConnection(pad) {
        if (!pad) return;
        GamepadState.connected = true;
        GamepadState.padIndex = pad.index;
        GamepadState.buttonLatch.clear();
        toggleGamepadHint(true);
        refreshGamepadFocusables();
        if (!GamepadState.pollHandle) {
          GamepadState.pollHandle = window.requestAnimationFrame(pollGamepad);
        }
      }

      function handleGamepadDisconnection(pad) {
        if (!pad || pad.index !== GamepadState.padIndex) return;
        GamepadState.connected = false;
        GamepadState.padIndex = null;
        GamepadState.buttonLatch.clear();
        GamepadState.nextMove = 0;
        if (GamepadState.pollHandle) {
          window.cancelAnimationFrame(GamepadState.pollHandle);
          GamepadState.pollHandle = null;
        }
        toggleGamepadHint(false);
        clearGamepadFocus();
      }

      function defaultState() {
        return {
          version: VERSION,
          createdAt: Date.now(),
          meta: { started: false, lastRoute: 'title', battleHistory: [], winStreak: 0 },
          settings: { autosave: true, textSpeed: 1, music: true, difficulty: 'standard' },
          player: {
            name: 'Aria Vanguard',
            level: 1,
            xp: 0,
            xpToLevel: 120,
            hp: 36,
            hpMax: 36,
            mp: 12,
            mpMax: 12,
            gold: 60,
            stats: { strength: 6, agility: 4, endurance: 5, spirit: 3 },
            tempShield: 0,
            equipment: {
              weapon: { name: 'Marshal Spear', power: 4 },
              armour: { name: 'Aegis Plating', defense: 3 },
              charm: { name: 'Signal Beacon', focus: 2 }
            },
            abilities: ['strike', 'rally', 'smite'],
            inventory: [ { id: 'potion', qty: 3 }, { id: 'ether', qty: 2 }, { id: 'bomb', qty: 1 } ],
            quickSlots: ['potion', 'ether'],
            skillPoints: 1
          },
          world: {
            region: 1,
            day: 1,
            streak: 0,
            map: generateMap(1),
            shopStock: generateShopStock(1),
            quests: seedQuests(),
            codex: seedCodex(),
            activeBattle: null,
            achievements: []
          }
        };
      }

      function seedQuests() {
        return QUEST_LIBRARY.map((q) => ({ ...q, progress: 0, completed: false, claimed: false }));
      }

      function seedCodex() {
        return {
          fundamentals: [
            'Win battles to earn XP and gold. Level up to gain skill points and improve abilities.',
            'Configure quick slots from the hub to ensure fast access to consumables in combat.',
            'Clear every node on the map to advance to a new region with tougher enemies and richer rewards.'
          ],
          combatTips: [
            'Rally before an expected heavy enemy hit to absorb damage.',
            'Smite consumes MP but cuts through high defense.',
            'Bombs ignore armor entirely—deploy them when an enemy digs in.'
          ],
          economy: [
            'Shop stock improves with every region. Spend gold to stay ahead of the curve.',
            'Claim quest rewards frequently to keep the war chest flush.'
          ]
        };
      }

      function generateMap(region) {
        const templates = [
          { name: 'Crosswind Approach', type: 'battle' },
          { name: 'Stormbreach Causeway', type: 'battle' },
          { name: 'Ruined Bastion', type: 'battle' },
          { name: 'Supply Cache', type: 'event' },
          { name: 'Emberkeep Gate', type: 'boss' }
        ];
        return templates.map((template, idx) => {
          const difficulty = region + idx;
          return {
            id: `${Date.now()}-${region}-${idx}`,
            name: template.name,
            type: template.type,
            difficulty,
            recommendedPower: 10 + difficulty * 6,
            cleared: false,
            reward: { xp: 40 + difficulty * 15, gold: 22 + difficulty * 9 }
          };
        });
      }

      function generateShopStock(region) {
        const stock = [ { id: 'potion', qty: 3 }, { id: 'ether', qty: 2 } ];
        if (region >= 2) stock.push({ id: 'bomb', qty: 1 });
        return stock;
      }

      function randomRange(min, max) { return Math.random() * (max - min) + min; }
      function getAbilityById(id) { return ABILITY_LIBRARY[id]; }
      function getItemById(id) { return ITEM_LIBRARY[id]; }
      function clone(value) {
        if (typeof structuredClone === 'function') {
          return structuredClone(value);
        }
        return JSON.parse(JSON.stringify(value));
      }

      function loadState() {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (!raw) return defaultState();
          const parsed = JSON.parse(raw);
          if (parsed.version !== VERSION) {
            pushToast('New build detected. Starting fresh.', 'warn');
            return defaultState();
          }
          return parsed;
        } catch (err) {
          console.error('Failed to load save', err);
          pushToast('Unable to load save. Starting a new expedition.', 'error');
          return defaultState();
        }
      }

      function persistState() {
        if (!state.meta.started) return;
        try {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
          pushToast('Progress saved.', 'success');
        } catch (err) {
          console.error('Failed to save', err);
          pushToast('Save failed. Storage may be full.', 'error');
        }
      }

      function persistStateIfAuto() {
        if (state.settings.autosave) {
          try { localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); } catch (err) { console.error(err); }
        }
      }

      function hardReset() {
        if (!confirm('This will erase your expedition. Continue?')) return;
        localStorage.removeItem(STORAGE_KEY);
        state = defaultState();
        currentRoute = 'title';
        render();
        pushToast('Expedition reset.', 'warn');
      }

      function setRoute(route) {
        if (!ROUTE_RENDERERS[route]) return;
        if (route !== 'title' && !state.meta.started) {
          pushToast('Start a new expedition first.', 'warn');
          currentRoute = 'title';
        } else {
          currentRoute = route;
        }
        state.meta.lastRoute = currentRoute;
        render();
      }

      function render() {
        navButtons.forEach((btn) => {
          const active = btn.dataset.route === currentRoute;
          btn.classList.toggle('primary', active);
          btn.disabled = btn.dataset.route !== 'title' && !state.meta.started;
        });
        saveBtn.disabled = !state.meta.started;
        resetBtn.disabled = false;
        ROUTE_RENDERERS[currentRoute]?.();
        decorateGamepadTargets(view);
        refreshGamepadFocusables();
      }

      function renderTitle() {
        view.innerHTML = `
          <section class="panel title-card">
            <div>
              <h1>Ultimate RPG</h1>
              <p class="muted">Lead the Vanguard through decisive encounters. Secure the front, unlock new regions, and keep momentum alive.</p>
            </div>
            <div class="cta-group">
              <button class="btn primary" id="btn-new-game">Start New Expedition</button>
              <button class="btn" id="btn-continue" ${state.meta.started ? '' : 'disabled'}>Continue</button>
              <button class="btn" id="btn-changelog">Patch Notes</button>
            </div>
            <div class="badge-strip">
              <span class="tag">Momentum Ready</span>
              <span class="tag">Turn-Based Combat</span>
              <span class="tag">Skill Tree & Quests</span>
            </div>
            <div class="panel outline">
              <strong>Quickstart:</strong>
              <ol class="muted">
                <li>Review your kit in the Hub and assign quick slots.</li>
                <li>Deploy to the map and clear encounters to push the region.</li>
                <li>Invest gold and skill points between battles to stay ahead.</li>
              </ol>
            </div>
          </section>
        `;
        view.querySelector('#btn-new-game').addEventListener('click', () => {
          state = defaultState();
          state.meta.started = true;
          state.meta.lastRoute = 'hub';
          pushToast('Expedition deployed. Vanguard, move out!', 'success');
          setRoute('hub');
          persistStateIfAuto();
        });
        view.querySelector('#btn-continue').addEventListener('click', () => {
          if (!state.meta.started) return;
          pushToast('Resuming expedition.', 'success');
          setRoute(state.meta.lastRoute || 'hub');
        });
        view.querySelector('#btn-changelog').addEventListener('click', showChangeLog);
      }

      function renderHub() {
        const p = state.player;
        view.innerHTML = `
          <div class="grid cols-2">
            <section class="panel">
              <div>
                <h2>${p.name}</h2>
                <p class="muted">Level ${p.level} Vanguard • Region ${state.world.region} • Day ${state.world.day}</p>
              </div>
              <div>
                <div class="stat-row"><span>HP</span><strong>${p.hp}/${p.hpMax}</strong></div>
                <div class="progress" aria-hidden="true"><span style="width:${(p.hp / p.hpMax) * 100}%"></span></div>
                <div class="stat-row"><span>MP</span><strong>${p.mp}/${p.mpMax}</strong></div>
                <div class="progress" aria-hidden="true"><span style="width:${(p.mp / p.mpMax) * 100}%"></span></div>
              </div>
              <div class="stat-list">
                <div class="stat-row"><span>Strength</span><strong>${p.stats.strength}</strong></div>
                <div class="stat-row"><span>Agility</span><strong>${p.stats.agility}</strong></div>
                <div class="stat-row"><span>Endurance</span><strong>${p.stats.endurance}</strong></div>
                <div class="stat-row"><span>Spirit</span><strong>${p.stats.spirit}</strong></div>
              </div>
              <div class="stat-row"><span>Gold</span><strong>${p.gold}</strong></div>
              <div class="stat-row"><span>XP</span><strong>${p.xp}/${p.xpToLevel}</strong></div>
              <div class="progress" aria-hidden="true"><span style="width:${Math.min(100, (p.xp / p.xpToLevel) * 100)}%"></span></div>
              <div class="badge-strip">
                ${p.skillPoints > 0 ? '<span class="tag">Skill points ready</span>' : ''}
                ${state.world.streak > 0 ? `<span class="tag">Win streak ${state.world.streak}</span>` : ''}
              </div>
              <div class="cta-group" style="justify-content:flex-start">
                <button class="btn primary" id="btn-open-map">Deploy to Map</button>
                <button class="btn" id="btn-open-shop">Visit Shop</button>
                <button class="btn" id="btn-rest">Rest (Full Heal)</button>
              </div>
            </section>
            <section class="panel">
              <h3>Quests</h3>
              <div class="quest-list">
                ${state.world.quests.map(renderQuest).join('')}
              </div>
            </section>
          </div>
          <section class="panel">
            <h3>Inventory & Quick Slots</h3>
            <div class="inventory">
              ${p.inventory.length ? p.inventory.map(renderInventoryItem).join('') : '<div class="empty-state">Inventory empty.</div>'}
            </div>
          </section>
        `;
        view.querySelector('#btn-open-map').addEventListener('click', () => setRoute('map'));
        view.querySelector('#btn-open-shop').addEventListener('click', () => setRoute('shop'));
        view.querySelector('#btn-rest').addEventListener('click', restAtCamp);
        view.querySelectorAll('[data-item-equip]').forEach((btn) => btn.addEventListener('click', () => configureQuickSlot(btn.dataset.itemEquip)));
        view.querySelectorAll('[data-item-use]').forEach((btn) => btn.addEventListener('click', () => useInventoryItem(btn.dataset.itemUse)));
        view.querySelectorAll('[data-claim-quest]').forEach((btn) => btn.addEventListener('click', () => claimQuestReward(btn.dataset.claimQuest)));
      }

      function renderQuest(quest) {
        const progressValue = Math.min(quest.goal, quest.progress);
        const pct = Math.min(100, (progressValue / quest.goal) * 100);
        return `
          <div class="quest" data-complete="${quest.completed}">
            <div><strong>${quest.name}</strong></div>
            <div class="muted">${quest.description}</div>
            <div class="progress"><span style="width:${pct}%"></span></div>
            <small>${progressValue}/${quest.goal}</small>
            <div class="badge-strip">
              <span class="tag">${quest.reward.xp} XP</span>
              <span class="tag">${quest.reward.gold} gold</span>
            </div>
            ${quest.completed && !quest.claimed ? `<button class="btn primary" data-claim-quest="${quest.id}">Claim Reward</button>` : ''}
          </div>
        `;
      }

      function renderInventoryItem(entry) {
        const item = getItemById(entry.id);
        if (!item) return '';
        const quickIndex = state.player.quickSlots.indexOf(entry.id);
        const quickLabel = quickIndex >= 0 ? `Quick Slot ${quickIndex + 1}` : 'Assign Quick Slot';
        const sellButton = currentRoute === 'shop'
          ? `<button class="btn warn" data-sell="${entry.id}">Sell (+${Math.round(item.price * 0.5)}g)</button>`
          : '';
        return `
          <div class="item">
            <div><strong>${item.name}</strong></div>
            <div class="muted">${item.description}</div>
            <div class="badge-strip">
              <span class="tag">Qty ${entry.qty}</span>
              <span class="tag">Value ${item.price}g</span>
            </div>
            <div class="cta-group" style="justify-content:flex-start">
              <button class="btn" data-item-use="${entry.id}">Use</button>
              <button class="btn" data-item-equip="${entry.id}">${quickLabel}</button>
              ${sellButton}
            </div>
          </div>
        `;
      }

      function renderMap() {
        const map = state.world.map;
        const allCleared = map.every((node) => node.cleared);
        view.innerHTML = `
          <section class="panel">
            <div>
              <h2>Region ${state.world.region} Deployment</h2>
              <p class="muted">Choose an objective. Clearing every node advances the campaign to the next region.</p>
            </div>
            <div class="map-grid">
              ${map.map(renderNodeCard).join('')}
            </div>
            ${allCleared ? '<div class="panel outline"><strong>Region cleared!</strong> Return to the hub to advance.</div>' : ''}
          </section>
        `;
        view.querySelectorAll('[data-node]').forEach((btn) => btn.addEventListener('click', () => {
          const nodeId = btn.dataset.node;
          const node = state.world.map.find((n) => n.id === nodeId);
          if (!node || node.cleared) {
            pushToast('This encounter is already cleared.', 'warn');
            return;
          }
          startBattle(node);
        }));
      }

      function renderNodeCard(node) {
        return `
          <article class="map-node" data-cleared="${node.cleared}">
            <div>
              <h4>${node.name}</h4>
              <p class="muted">Type: ${node.type === 'battle' ? 'Skirmish' : node.type === 'boss' ? 'Boss' : 'Event'}</p>
            </div>
            <div class="stat-row"><span>Recommended Power</span><strong>${node.recommendedPower}</strong></div>
            <div class="badge-strip">
              <span class="tag">XP ${node.reward.xp}</span>
              <span class="tag">Gold ${node.reward.gold}</span>
            </div>
            <button class="btn primary" data-node="${node.id}" ${node.cleared ? 'disabled' : ''}>Engage</button>
          </article>
        `;
      }

      function renderBattle() {
        const battle = state.world.activeBattle;
        if (!battle) {
          view.innerHTML = '<div class="panel empty-state">No battle in progress. Choose a node from the map.</div>';
          return;
        }
        const { playerSnapshot, enemy } = battle;
        view.innerHTML = `
          <section class="panel battle-wrap">
            <div class="battle-stats">
              <div class="panel outline">
                <h3>${playerSnapshot.name}</h3>
                <div class="stat-row"><span>HP</span><strong>${playerSnapshot.hp}/${playerSnapshot.hpMax}</strong></div>
                <div class="progress"><span style="width:${(playerSnapshot.hp / playerSnapshot.hpMax) * 100}%"></span></div>
                <div class="stat-row"><span>MP</span><strong>${playerSnapshot.mp}/${playerSnapshot.mpMax}</strong></div>
                <div class="progress"><span style="width:${(playerSnapshot.mp / playerSnapshot.mpMax) * 100}%"></span></div>
                <div class="badge-strip">
                  <span class="tag">Shield ${playerSnapshot.tempShield || 0}</span>
                  <span class="tag">Turn: ${battle.turn === 'player' ? 'Player' : 'Enemy'}</span>
                </div>
              </div>
              <div class="panel outline">
                <h3>${enemy.name}</h3>
                <div class="muted">${enemy.description}</div>
                <div class="stat-row"><span>HP</span><strong>${enemy.hp}/${enemy.hpMax}</strong></div>
                <div class="progress"><span style="width:${(enemy.hp / enemy.hpMax) * 100}%"></span></div>
                <div class="badge-strip">
                  <span class="tag">Attack ${enemy.attack}</span>
                  <span class="tag">Defense ${enemy.defense}</span>
                </div>
              </div>
            </div>
            <div class="panel outline">
              <h3>Actions</h3>
              <div class="badge-strip">
                ${playerSnapshot.abilities.map((id) => {
                  const ability = getAbilityById(id);
                  if (!ability) return '';
                  const disabled = battle.turn !== 'player' || ability.cost > playerSnapshot.mp;
                  return `<button class="btn" data-ability="${ability.id}" ${disabled ? 'disabled' : ''}>${ability.name}${ability.cost ? ` (MP ${ability.cost})` : ''}</button>`;
                }).join('')}
                <button class="btn" id="btn-basic-attack" ${battle.turn !== 'player' ? 'disabled' : ''}>Basic Attack</button>
                <button class="btn" id="btn-use-item" ${battle.turn !== 'player' ? 'disabled' : ''}>Quick Item</button>
                <button class="btn" id="btn-retreat">Retreat</button>
              </div>
            </div>
            <div>
              <h3>Combat Log</h3>
              <div class="battle-log">
                ${battle.log.map((entry) => `<div class="log-line">${entry}</div>`).join('')}
              </div>
            </div>
          </section>
        `;
        view.querySelector('#btn-basic-attack').addEventListener('click', playerAttack);
        view.querySelector('#btn-use-item').addEventListener('click', useQuickItem);
        view.querySelector('#btn-retreat').addEventListener('click', attemptRetreat);
        view.querySelectorAll('[data-ability]').forEach((btn) => btn.addEventListener('click', () => useAbility(btn.dataset.ability)));
        const logEl = view.querySelector('.battle-log');
        logEl.scrollTop = logEl.scrollHeight;
      }

      function renderShop() {
        const stock = state.world.shopStock;
        const inventory = state.player.inventory;
        view.innerHTML = `
          <div class="grid cols-2">
            <section class="panel">
              <h3>Quartermaster Stock</h3>
              <div class="shop-grid">
                ${stock.length ? stock.map(renderShopCard).join('') : '<div class="empty-state">Shop will restock next region.</div>'}
              </div>
            </section>
            <section class="panel">
              <h3>Your Inventory</h3>
              <div class="inventory">
                ${inventory.length ? inventory.map(renderInventoryItem).join('') : '<div class="empty-state">Inventory empty.</div>'}
              </div>
            </section>
          </div>
        `;
        view.querySelectorAll('[data-buy]').forEach((btn) => btn.addEventListener('click', () => purchaseItem(btn.dataset.buy)));
        view.querySelectorAll('[data-sell]').forEach((btn) => btn.addEventListener('click', () => sellItem(btn.dataset.sell)));
        view.querySelectorAll('[data-item-equip]').forEach((btn) => btn.addEventListener('click', () => configureQuickSlot(btn.dataset.itemEquip)));
        view.querySelectorAll('[data-item-use]').forEach((btn) => btn.addEventListener('click', () => useInventoryItem(btn.dataset.itemUse)));
      }

      function renderShopCard(entry) {
        const item = getItemById(entry.id);
        if (!item) return '';
        return `
          <div class="shop-card">
            <div><strong>${item.name}</strong></div>
            <div class="muted">${item.description}</div>
            <div class="badge-strip">
              <span class="tag">Stock ${entry.qty}</span>
              <span class="tag">Cost ${item.price}g</span>
            </div>
            <button class="btn primary" data-buy="${entry.id}" ${entry.qty <= 0 ? 'disabled' : ''}>Buy</button>
          </div>
        `;
      }

      function renderSkills() {
        const skills = [
          { id: 'str-train', name: 'Assault Conditioning', description: 'Increase Strength by 1 permanently.', cost: 1, action: () => { state.player.stats.strength += 1; pushToast('Strength increased.', 'success'); } },
          { id: 'endurance-train', name: 'Bulwark Weave', description: 'Increase maximum HP by 6.', cost: 1, action: () => { state.player.hpMax += 6; state.player.hp += 6; pushToast('Maximum HP increased.', 'success'); } },
          { id: 'spirit-train', name: 'Radiant Focus', description: 'Increase Spirit by 1 and MP by 2.', cost: 1, action: () => { state.player.stats.spirit += 1; state.player.mpMax += 2; state.player.mp += 2; pushToast('Spirit refined.', 'success'); } }
        ];
        view.innerHTML = `
          <section class="panel">
            <div>
              <h2>Skillforge</h2>
              <p class="muted">Allocate skill points gained from levelling.</p>
            </div>
            <p>Available Skill Points: <strong>${state.player.skillPoints}</strong></p>
            <div class="skills-grid">
              ${skills.map((skill) => renderSkillCard(skill)).join('')}
            </div>
          </section>
        `;
        skills.forEach((skill) => view.querySelector(`[data-skill="${skill.id}"]`)?.addEventListener('click', () => spendSkillPoint(skill)));
      }

      function renderSkillCard(skill) {
        return `
          <div class="skill-card">
            <div><strong>${skill.name}</strong></div>
            <div class="muted">${skill.description}</div>
            <div class="badge-strip"><span class="tag">Cost ${skill.cost} SP</span></div>
            <button class="btn primary" data-skill="${skill.id}">${state.player.skillPoints >= skill.cost ? 'Unlock' : 'Need SP'}</button>
          </div>
        `;
      }

      function renderSettings() {
        const s = state.settings;
        view.innerHTML = `
          <section class="panel">
            <h2>Settings & Accessibility</h2>
            <div class="settings-list">
              <label class="switch">Autosave every action
                <input type="checkbox" id="setting-autosave" ${s.autosave ? 'checked' : ''}>
              </label>
              <label class="switch">Enable soundscape cues
                <input type="checkbox" id="setting-music" ${s.music ? 'checked' : ''}>
              </label>
              <label class="switch">Text speed multiplier
                <input type="range" id="setting-text-speed" min="0.5" max="2" step="0.5" value="${s.textSpeed}">
              </label>
              <label class="switch">Difficulty curve
                <select id="setting-difficulty">
                  <option value="story" ${s.difficulty === 'story' ? 'selected' : ''}>Story</option>
                  <option value="standard" ${s.difficulty === 'standard' ? 'selected' : ''}>Standard</option>
                  <option value="veteran" ${s.difficulty === 'veteran' ? 'selected' : ''}>Veteran</option>
                </select>
              </label>
            </div>
          </section>
        `;
        view.querySelector('#setting-autosave').addEventListener('change', (ev) => { state.settings.autosave = ev.target.checked; pushToast(`Autosave ${ev.target.checked ? 'enabled' : 'disabled'}.`, 'success'); });
        view.querySelector('#setting-music').addEventListener('change', (ev) => { state.settings.music = ev.target.checked; pushToast(`Soundscape ${ev.target.checked ? 'enabled' : 'muted'}.`, 'success'); });
        view.querySelector('#setting-text-speed').addEventListener('change', (ev) => { state.settings.textSpeed = parseFloat(ev.target.value); pushToast(`Text speed set to ${state.settings.textSpeed}x.`, 'success'); });
        view.querySelector('#setting-difficulty').addEventListener('change', (ev) => { state.settings.difficulty = ev.target.value; pushToast(`Difficulty set to ${state.settings.difficulty}.`, 'success'); });
      }

      function renderCodex() {
        const c = state.world.codex;
        view.innerHTML = `
          <section class="panel codex">
            <section>
              <h3>Fundamentals</h3>
              <ul>${c.fundamentals.map((line) => `<li>${line}</li>`).join('')}</ul>
            </section>
            <section>
              <h3>Combat Tips</h3>
              <ul>${c.combatTips.map((line) => `<li>${line}</li>`).join('')}</ul>
            </section>
            <section>
              <h3>Economy & Momentum</h3>
              <ul>${c.economy.map((line) => `<li>${line}</li>`).join('')}</ul>
            </section>
          </section>
        `;
      }

      function startBattle(node) {
        const enemyTemplate = ENEMY_DECK[node.difficulty % ENEMY_DECK.length];
        const difficultyMod = 1 + (node.difficulty - 1) * 0.12;
        const enemy = {
          name: enemyTemplate.name,
          description: enemyTemplate.description,
          hp: Math.round(enemyTemplate.hpBase * difficultyMod),
          hpMax: Math.round(enemyTemplate.hpBase * difficultyMod),
          attack: Math.round(enemyTemplate.attack * difficultyMod),
          defense: Math.round(enemyTemplate.defense * (0.9 + difficultyMod * 0.2)),
          nodeId: node.id
        };
        const snapshot = {
          name: state.player.name,
          hp: state.player.hp,
          hpMax: state.player.hpMax,
          mp: state.player.mp,
          mpMax: state.player.mpMax,
          abilities: [...state.player.abilities],
          stats: { ...state.player.stats },
          equipment: clone(state.player.equipment),
          tempShield: state.player.tempShield || 0
        };
        state.world.activeBattle = { nodeId: node.id, turn: 'player', playerSnapshot: snapshot, enemy, log: ['Engagement initiated.'] };
        setRoute('battle');
      }

      function playerAttack() {
        const battle = state.world.activeBattle;
        if (!battle || battle.turn !== 'player') return;
        const player = battle.playerSnapshot;
        const enemy = battle.enemy;
        const weapon = player.equipment.weapon;
        const roll = randomRange(0.85, 1.25);
        const damage = Math.max(1, Math.round((player.stats.strength + weapon.power) * roll - enemy.defense * 0.5));
        enemy.hp = Math.max(0, enemy.hp - damage);
        battle.log.push(`<strong>${player.name}</strong> deals ${damage} damage.`);
        endPlayerTurn();
      }

      function useAbility(abilityId) {
        const battle = state.world.activeBattle;
        if (!battle || battle.turn !== 'player') return;
        const ability = getAbilityById(abilityId);
        const player = battle.playerSnapshot;
        if (!ability) return;
        if (ability.cost > player.mp) {
          pushToast('Not enough MP.', 'warn');
          return;
        }
        player.mp -= ability.cost;
        const result = ability.execute({ player, enemy: battle.enemy });
        battle.log.push(`<strong>${player.name}</strong>: ${result}`);
        endPlayerTurn();
      }

      function useQuickItem() {
        const battle = state.world.activeBattle;
        if (!battle || battle.turn !== 'player') return;
        const quickItemId = state.player.quickSlots[0];
        if (!quickItemId) {
          pushToast('Assign a quick slot item on the hub.', 'warn');
          return;
        }
        useInventoryItem(quickItemId, true);
      }

      function useInventoryItem(itemId, fromBattle = false) {
        const entry = state.player.inventory.find((i) => i.id === itemId);
        const item = getItemById(itemId);
        if (!entry || !item) {
          pushToast('Item unavailable.', 'warn');
          return;
        }
        const battle = state.world.activeBattle;
        const targetEnemy = fromBattle ? battle?.enemy : null;
        item.use(state.player, targetEnemy);
        entry.qty -= 1;
        if (entry.qty <= 0) {
          state.player.inventory = state.player.inventory.filter((i) => i.qty > 0);
          state.player.quickSlots = state.player.quickSlots.filter((slot) => slot !== itemId);
        }
        pushToast(`${item.name} used.`, 'success');
        if (fromBattle && battle) {
          if (targetEnemy) battle.log.push(`<strong>${state.player.name}</strong> uses ${item.name}.`);
          syncBattleSnapshot();
          endPlayerTurn();
        } else {
          render();
        }
        persistStateIfAuto();
      }

      function configureQuickSlot(itemId) {
        if (!state.player.quickSlots.includes(itemId)) {
          state.player.quickSlots[0] = itemId;
          pushToast('Quick slot updated.', 'success');
        } else {
          state.player.quickSlots = state.player.quickSlots.filter((slot) => slot !== itemId);
          pushToast('Quick slot cleared.', 'warn');
        }
        render();
        persistStateIfAuto();
      }

      function attemptRetreat() {
        if (!state.world.activeBattle) return;
        const success = Math.random() < 0.55;
        if (success) {
          state.world.activeBattle.log.push('Retreat successful. Returning to hub.');
          state.world.activeBattle = null;
          state.world.streak = 0;
          setRoute('hub');
          pushToast('Retreated safely.', 'warn');
        } else {
          state.world.activeBattle.log.push('Retreat failed! Enemy capitalises.');
          enemyTurn();
        }
      }

      function endPlayerTurn() {
        syncBattleSnapshot();
        checkBattleResolution();
        const battle = state.world.activeBattle;
        if (battle) {
          battle.turn = 'enemy';
          enemyTurn();
        }
        render();
      }

      function syncBattleSnapshot() {
        const battle = state.world.activeBattle;
        if (!battle) return;
        battle.playerSnapshot.hp = state.player.hp;
        battle.playerSnapshot.hpMax = state.player.hpMax;
        battle.playerSnapshot.mp = state.player.mp;
        battle.playerSnapshot.mpMax = state.player.mpMax;
        battle.playerSnapshot.tempShield = state.player.tempShield || 0;
      }

      function enemyTurn() {
        const battle = state.world.activeBattle;
        if (!battle) return;
        const enemy = battle.enemy;
        const player = battle.playerSnapshot;
        if (enemy.hp <= 0) {
          checkBattleResolution();
          return;
        }
        const roll = randomRange(0.8, 1.15);
        let damage = Math.max(1, Math.round(enemy.attack * roll - state.player.stats.endurance * 0.3));
        if (player.tempShield && player.tempShield > 0) {
          const absorbed = Math.min(player.tempShield, damage);
          player.tempShield -= absorbed;
          damage -= absorbed;
          battle.log.push(`<strong>${enemy.name}</strong> hits the shield for ${absorbed}.`);
        }
        if (damage > 0) {
          state.player.hp = Math.max(0, state.player.hp - damage);
          player.hp = state.player.hp;
          battle.log.push(`<strong>${enemy.name}</strong> deals ${damage} damage.`);
        } else {
          battle.log.push(`<strong>${enemy.name}</strong> fails to penetrate the defenses.`);
        }
        checkBattleResolution();
        if (state.world.activeBattle) {
          state.world.activeBattle.turn = 'player';
          render();
        }
      }

      function checkBattleResolution() {
        const battle = state.world.activeBattle;
        if (!battle) return;
        const { enemy } = battle;
        if (enemy.hp <= 0) {
          concludeBattle(true, enemy);
        } else if (state.player.hp <= 0) {
          concludeBattle(false, enemy);
        }
      }

      function concludeBattle(victory, enemy) {
        const battle = state.world.activeBattle;
        if (!battle) return;
        const node = state.world.map.find((n) => n.id === battle.nodeId);
        if (victory) {
          battle.log.push('<strong>Victory!</strong> The enemy is defeated.');
          state.world.streak += 1;
          state.meta.winStreak = Math.max(state.meta.winStreak, state.world.streak);
          if (node) node.cleared = true;
          awardRewards(node?.reward || { xp: 10, gold: 5 });
          updateQuestProgress('clear-encounters', 1);
          checkRegionClear();
          pushToast('Encounter cleared!', 'success');
        } else {
          battle.log.push('<strong>Defeat.</strong> Return to the hub to recover.');
          state.world.streak = 0;
          state.player.gold = Math.max(0, state.player.gold - 10);
          state.player.hp = Math.round(state.player.hpMax * 0.4);
          state.player.mp = Math.round(state.player.mpMax * 0.5);
          pushToast('You were defeated. Regroup at the hub.', 'warn');
        }
        state.world.activeBattle = null;
        setRoute('hub');
        persistStateIfAuto();
      }

      function awardRewards(reward) {
        state.player.gold += reward.gold;
        state.player.xp += reward.xp;
        updateQuestProgress('gather-gold', reward.gold);
        while (state.player.xp >= state.player.xpToLevel) {
          state.player.xp -= state.player.xpToLevel;
          levelUp();
        }
      }

      function levelUp() {
        state.player.level += 1;
        state.player.skillPoints += 1;
        state.player.hpMax += 4;
        state.player.mpMax += 2;
        state.player.hp = state.player.hpMax;
        state.player.mp = state.player.mpMax;
        state.player.xpToLevel = Math.round(state.player.xpToLevel * 1.15);
        pushToast(`Level up! Level ${state.player.level}`, 'success');
      }

      function updateQuestProgress(id, amount) {
        const quest = state.world.quests.find((q) => q.id === id);
        if (!quest || quest.completed) return;
        quest.progress += amount;
        if (quest.progress >= quest.goal) {
          quest.completed = true;
          pushToast(`${quest.name} ready to claim.`, 'success');
        }
      }

      function claimQuestReward(id) {
        const quest = state.world.quests.find((q) => q.id === id);
        if (!quest || !quest.completed || quest.claimed) return;
        quest.claimed = true;
        awardRewards(quest.reward);
        pushToast(`Quest reward claimed: ${quest.reward.gold}g & ${quest.reward.xp} XP.`, 'success');
        render();
        persistStateIfAuto();
      }

      function restAtCamp() {
        state.player.hp = state.player.hpMax;
        state.player.mp = state.player.mpMax;
        state.player.tempShield = 0;
        pushToast('Fully rested and battle ready.', 'success');
        persistStateIfAuto();
        render();
      }

      function checkRegionClear() {
        if (state.world.map.every((node) => node.cleared)) {
          state.world.region += 1;
          state.world.day += 1;
          state.world.map = generateMap(state.world.region);
          state.world.shopStock = generateShopStock(state.world.region);
          pushToast(`Region advanced to ${state.world.region}. Shop restocked!`, 'success');
        } else {
          state.world.day += 1;
        }
      }

      function purchaseItem(itemId) {
        const stock = state.world.shopStock.find((entry) => entry.id === itemId);
        const item = getItemById(itemId);
        if (!stock || !item) return;
        if (stock.qty <= 0) {
          pushToast('Out of stock.', 'warn');
          return;
        }
        if (state.player.gold < item.price) {
          pushToast('Not enough gold.', 'warn');
          return;
        }
        state.player.gold -= item.price;
        const invEntry = state.player.inventory.find((entry) => entry.id === itemId);
        if (invEntry) invEntry.qty += 1; else state.player.inventory.push({ id: itemId, qty: 1 });
        stock.qty -= 1;
        pushToast(`${item.name} acquired.`, 'success');
        render();
        persistStateIfAuto();
      }

      function sellItem(itemId) {
        const entry = state.player.inventory.find((i) => i.id === itemId);
        const item = getItemById(itemId);
        if (!entry || !item) {
          pushToast('Item unavailable.', 'warn');
          return;
        }
        entry.qty -= 1;
        state.player.gold += Math.round(item.price * 0.5);
        if (entry.qty <= 0) {
          state.player.inventory = state.player.inventory.filter((i) => i.qty > 0);
          state.player.quickSlots = state.player.quickSlots.filter((slot) => slot !== itemId);
        }
        pushToast(`${item.name} sold.`, 'success');
        render();
        persistStateIfAuto();
      }

      function showChangeLog() {
        const messages = [
          'v3.0.0 • Full usability overhaul: rebuilt UI, simplified flow, battle-ready defaults.',
          'v3.0.0 • Live quest tracking, quick slot assignments, and automated region restock.',
          'v3.0.0 • Added codex briefing, skillforge improvements, and polished combat pacing.'
        ];
        alert(messages.join('\n'));
      }

      function pushToast(message, tone = 'info') {
        const toast = document.createElement('div');
        toast.className = `toast ${tone === 'info' ? '' : tone}`.trim();
        toast.textContent = message;
        toastWrap.appendChild(toast);
        setTimeout(() => {
          toast.classList.add('fade-out');
          setTimeout(() => toast.remove(), 400);
        }, 2800);
      }

      function bindNav() {
        navButtons.forEach((btn) => {
          btn.addEventListener('click', () => setRoute(btn.dataset.route));
        });
        saveBtn.addEventListener('click', persistState);
        resetBtn.addEventListener('click', hardReset);
        document.addEventListener('keydown', (ev) => {
          if (ev.ctrlKey && ev.key.toLowerCase() === 's') {
            ev.preventDefault();
            persistState();
          }
          const routeKeys = {
            t: 'title',
            h: 'hub',
            m: 'map',
            b: 'battle',
            s: 'shop',
            k: 'skills',
            g: 'settings',
            c: 'codex'
          };
          const nextRoute = routeKeys[ev.key.toLowerCase()];
          if (nextRoute) {
            ev.preventDefault();
            setRoute(nextRoute);
          }
        });
        decorateGamepadTargets(document.querySelector('nav'));
        refreshGamepadFocusables();
      }

      window.addEventListener('gamepadconnected', (event) => handleGamepadConnection(event.gamepad));
      window.addEventListener('gamepaddisconnected', (event) => handleGamepadDisconnection(event.gamepad));

      function init() {
        bindNav();
        state = loadState();
        if (state.meta.started) {
          currentRoute = state.meta.lastRoute || 'hub';
        } else {
          currentRoute = 'title';
        }
        render();
      }

      init();
    })();
  </script>
</body>
</html>
